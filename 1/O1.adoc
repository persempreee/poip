:imagesdir: pictures1

== Отчет 1
== Задание 1
* Создать проект C++ с main.cpp

Для создания проекта была использована интегрируемая среда разработки IAR Embedded Workbench

image::O1_1.png[]
Рисунок 1 - Создание нового проекта

Выбираем Язык С++ и глобальную функцию main

image::O1_2.png[]
Рисунок 2 - Выбор языка программирования и глобальной функции

Сохраним проект под каким-либо именем. В свойствах проекта выбираем модель микроконтроллера ST ⇒ STM32F4⇒ STM32F411⇒ ST STM32F411RE. Для этого правой кнопкой мыши щелкнуть по проекту, выбирать Options и далее в категории General Option выбрать закладку Target.

image::O1_3.png[]
Рисунок  3 - Выбор микроконтроллера

Теперь проект выглядит так

image::O1_4.png[]
Рисунок 4 - стартовый вид проекта

* Подключить к проекту файл cstartup.cpp

Для подключения файла cstartup.cpp, первым делом необходимо его найти. Для этого клонируем папку проекта преподавателя, набрав в командной строке:

----
git clone https://github.com/lamer0k/CortexLib.git
----

image::O1_5.png[]
Рисунок 5 - Копирование папки через командную строку

В этом случае путь папке C::\User\User.

В папке находим файл cstartup.cpp.Добавим его к проекту:

Для этого нужно нажать правую кнопку мыши на проекте и выбрав пункт Add⇒Add Files…, а затем выбрать файл startup_stm32F411.cpp.

image::O1_6.png[]
Рисунок 6 - Добавление файла

* Создать папки AbstractHardware/Registers/FiledValues, Common, Application, FreeRtos

Данные папки требуется создать в папке, кеуда был сохранен проект. Так же их можно скопировать с клонированной папки преподавателя.

image::O1_7.png[]
Рисунок 7 - Структура после добавления папок

* Создать структуру проекта в соответствии со структурой папок

Теперь необходимо создать точно такую же структуру в проекте IAR Workbench, как и структура папок. Для этого необходимо нажать правой мышкой на проект, и выбрать меню Add=>Ggroup и создать группы Abstract_Hardware, Application, Common, FreeRtos.

image::O1_8.png[]
Рисунок 8 - Изменение структуры проекта

Поочередно добавляем все папки сохраняя их иерархическую структуру.

В конечном итоге у вас должна появиться вот такая структура:

image::O1_9.png[]
Рисунок 9 - Структура после добавления папок

* Настроить stack и heap

Для включения анализа глубины стека достаточно поставить галочку в меню Option=>Linker=>Advanced=>Enable stack usage analysis

image::O1_10.png[]
Рисунок 10 - Опция анализа глубины стэка
[#image-6]
.Размер стека
image::6.png[]

* Скопировать содержимое папок Registers и Common в папки проекта

Все файлы были скопированы в папки проекты, сохраняя их структуру.

* Написать программу в main.cpp

Код взят из примера программы преподавателя

----
#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::ODR::ODR5::Enable::Set() ;
  GPIOC::ODR::ODR5::Disable::Set() ;
  return 0 ;
}
----

Во время компиляции возникли ошибки. Это было связанно с тем, что в файлах gpiocfieldvalues.hpp и rccfieldvalues.hpp значения регистра ODR5 были прописаны как Value1, Value0, а не Enable, Outputy.

image::O1_11.png[]

image::O1_12.png[]

image::O1_13.png[]

image::O1_14.png[]

image::O1_15.png[]

Теперь компиляция прошла успешно, диоды мигают.

== Задание 2

Следующим шагом является прошивка программы в микроконтроллер.

Для начала производили отладку в симуляторе для проверки работоспособности программы.

* Откомпилировать и отлинковать программу

Для компиляции без загрузки в симулятор можно воспользоваться командой make

image::O1_16.png[]

Ошибок не выявлено

* Запустить программу в симуляторе

Для запуска симуляции используем следующию кнопку

image::O1_17.png[]

Или сочетание клавиш *Ctrl+D*

* Сделать пошаговую отладку

Пошаговая отладка выполняется следующими кнопками:

image::O1_18.png[]

Или клавиши *F10, F11, F12*

* Настроить Debugger на отладку через StLink

Для настройки идем в Project=>Options…​=>ST-LINK и выбираем параметры как показано на рисунке ниже

image::O1_19.png[]

* Подключить плату к компьютеру

Подключаем плату к компьютеру через USB порт.

При скачивании IAR должны быть установлены все необходимые драйвера, в противном случае программа не увидит плату

* Загрузить программу в плату

Загружаем программу в плату сочетанием клавиш *Ctrl+D*. Возможно столкнуться с ошибкой:

image::O1_20.png[]

Она решается, если задать путь к файлу startup.cpp

image::O1_21.png[]

Теперь проводим отладку на плате

* Выполнить пошаговую отладку

Выполняем пошаговую отладку клавишей *F10*.

* Описать полученный результат

Код программы с построчным описанием:

----
#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main() //глобальная функция
//тело функции
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ; //разрешение тактирования порта С
  GPIOC::MODER::MODER5::Output::Set() ; //РС 5 - выход
  GPIOC::ODR::ODR5::Enable::Set() ; //включение диода РС 5 
  GPIOC::ODR::ODR5::Disable::Set() ; //выключение диода PC 5
  return 0 ; //конец выполнения программы
}
----

== Задание 3

Следующим заданием являлось работа с организацией памяти, настройкой стека и кучи. При неверной настройке данных параметров программа может не выполняться. Так же грамотная настройка позволит нам сократить вес итоговой программы.

* Запустить анализатор стека. Узнать рекомендуемый размер стека.

При настройке мы включили анализ стека.(см. <<Анализ стека>>) Рекомендуемый размер стека мы можем посмотреть в .map файле. Рекомендуемый размер стека:
16

image::O1_22.png[]

* Изменить в проекте размер стека на рекомендуемый

Изменим в проекте размер стека на рекомендуемый

image::O1_23.png[]

* Описать содержание map файла

В .map файле написаны размеры составляющих проекта Мы можем увидеть размер стека

image::O1_24.png[]

Размер отдельных элементов:

image::O1_25.png[]

Размер нашего файла:

image::O1_26.png[]

* Поставить размер HEAP равный нулю. Объяснить почему так можно сделать. И почему STACK нельзя

Размер кучи HEAP можно поставить в 0, т.к. не используется динамическая память. Размер STACK нельзя поставить в 0, т.к. при использовании функций будет невозможна запись адреса возврата. Однако, в нашем случае, путем эксперимента было установлено, что даже при выставлении 0 в стеке программа запускается и диоды мигают.

* Добавить проект в Git и сделать синхронизацию с GitHub

* Сделать отчет по каждому пункту каждого задания в файле .adoc. Выложить файл в GitHub

* Прислать ссылку на GitHub преподавателю для проверки